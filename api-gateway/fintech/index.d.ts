/** Declaration file generated by dts-gen */

export = r7insight_node;

declare class r7insight_node {
    constructor(...args: any[]);

    closeConnection(...args: any[]): void;

    log(...args: any[]): void;

    setDefaultEncoding(...args: any[]): void;

    toLevel(...args: any[]): void;

    static addAbortSignal(signal: any, stream: any): any;

    static bufferDrainEvent: string;

    static bunyanStream(opts: any): any;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static compose(streams: any): any;

    static connectedEvent: string;

    static defaultMaxListeners: number;

    static destroy(stream: any, err: any): void;

    static disconnectedEvent: string;

    static drainWritableEvent: string;

    static errorEvent: string;

    static errorMonitor: any;

    static finishWritableEvent: string;

    static finished(stream: any, options: any, callback: any, ...args: any[]): any;

    static fromWeb(writableStream: any, options: any): any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static isDisturbed(stream: any): any;

    static isErrored(stream: any): any;

    static isReadable(stream: any): any;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static logEvent: string;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static pipeWritableEvent: string;

    static pipeline(streams: any): any;

    static provisionWinston(winston: any, Transport: any): void;

    static setMaxListeners(n: any, eventTargets: any): void;

    static timeoutEvent: string;

    static toWeb(streamWritable: any): any;

    static unpipeWritableEvent: string;

    static usingDomains: boolean;

}

declare namespace r7insight_node {
    class Duplex {
        constructor(options: any);

        cork(): void;

        end(chunk: any, encoding: any, cb: any): any;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Duplex: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): void;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static fromWeb(pair: any, options: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static toWeb(duplex: any): any;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class EventEmitterAsyncResource {
        constructor(...args: any[]);

        emit(...args: any[]): void;

        emitDestroy(...args: any[]): void;

        static EventEmitterAsyncResource: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class PassThrough {
        constructor(options: any);

        static PassThrough: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): void;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static fromWeb(pair: any, options: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static toWeb(duplex: any): any;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Readable {
        constructor(options: any);

        addListener(ev: any, fn: any): any;

        asIndexedPairs(args: any): any;

        destroy(err: any, cb: any): any;

        drop(args: any): any;

        every(args: any): any;

        filter(args: any): any;

        find(args: any): any;

        flatMap(args: any): any;

        forEach(args: any): any;

        isPaused(): any;

        iterator(options: any): any;

        map(args: any): any;

        off(ev: any, fn: any): any;

        on(ev: any, fn: any): any;

        pause(): any;

        pipe(dest: any, pipeOpts: any): any;

        push(chunk: any, encoding: any): any;

        read(n: any): any;

        reduce(args: any): any;

        removeAllListeners(ev: any, ...args: any[]): any;

        removeListener(ev: any, fn: any): any;

        resume(): any;

        setEncoding(enc: any): any;

        some(args: any): any;

        take(args: any): any;

        toArray(args: any): any;

        unpipe(dest: any): any;

        unshift(chunk: any, encoding: any): any;

        wrap(stream: any): any;

        static Readable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): void;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(iterable: any, opts: any): any;

        static fromWeb(readableStream: any, options: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static toWeb(streamReadable: any, options: any): any;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Stream {
        constructor(opts: any);

        pipe(dest: any, options: any): any;

        static Stream: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): void;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class Transform {
        constructor(options: any);

        static Transform: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): void;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static fromWeb(pair: any, options: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static toWeb(duplex: any): any;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Writable {
        constructor(options: any);

        cork(): void;

        destroy(err: any, cb: any): any;

        end(chunk: any, encoding: any, cb: any): any;

        pipe(): void;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Writable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): void;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static fromWeb(writableStream: any, options: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static toWeb(streamWritable: any): any;

        static usingDomains: boolean;

    }

    class WritableState {
        constructor(options: any, stream: any, isDuplex: any);

        getBuffer(): any;

    }

    namespace Duplex {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            asIndexedPairs(args: any): any;

            destroy(err: any, cb: any): any;

            drop(args: any): any;

            every(args: any): any;

            filter(args: any): any;

            find(args: any): any;

            flatMap(args: any): any;

            forEach(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            reduce(args: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            some(args: any): any;

            take(args: any): any;

            toArray(args: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static fromWeb(readableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamReadable: any, options: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static fromWeb(writableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamWritable: any): any;

            static usingDomains: boolean;

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace PassThrough {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Readable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.PassThrough.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Readable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Readable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Readable.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Stream {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Stream.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Transform {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Transform.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Writable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Duplex.Writable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace finished {
            function finished(stream: any, opts: any): any;

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace EventEmitter {
        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace EventEmitterAsyncResource {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace PassThrough {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            asIndexedPairs(args: any): any;

            destroy(err: any, cb: any): any;

            drop(args: any): any;

            every(args: any): any;

            filter(args: any): any;

            find(args: any): any;

            flatMap(args: any): any;

            forEach(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            reduce(args: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            some(args: any): any;

            take(args: any): any;

            toArray(args: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static fromWeb(readableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamReadable: any, options: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static fromWeb(writableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamWritable: any): any;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Readable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Duplex.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Readable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static PassThrough: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Readable.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Transform {
                constructor(options: any);

                static PassThrough: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static PassThrough: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Stream.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static PassThrough: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static PassThrough: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static PassThrough: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Transform.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static PassThrough: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static PassThrough: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static PassThrough: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.PassThrough.Writable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace finished {
            function finished(stream: any, opts: any): any;

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Readable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static fromWeb(writableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamWritable: any): any;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Readable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Duplex.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Readable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static PassThrough: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.PassThrough.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Transform {
                constructor(options: any);

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Readable: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Stream.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Readable: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Transform.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Readable: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Readable: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Readable.Writable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace finished {
            function finished(stream: any, opts: any): any;

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Stream {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            asIndexedPairs(args: any): any;

            destroy(err: any, cb: any): any;

            drop(args: any): any;

            every(args: any): any;

            filter(args: any): any;

            find(args: any): any;

            flatMap(args: any): any;

            forEach(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            reduce(args: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            some(args: any): any;

            take(args: any): any;

            toArray(args: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static fromWeb(readableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamReadable: any, options: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Transform {
            constructor(options: any);

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static fromWeb(writableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamWritable: any): any;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Duplex.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static PassThrough: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static PassThrough: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.PassThrough.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Readable: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Readable.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Transform.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Readable: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Transform {
                constructor(options: any);

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Stream.Writable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace finished {
            function finished(stream: any, opts: any): any;

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Transform {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            asIndexedPairs(args: any): any;

            destroy(err: any, cb: any): any;

            drop(args: any): any;

            every(args: any): any;

            filter(args: any): any;

            find(args: any): any;

            flatMap(args: any): any;

            forEach(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            reduce(args: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            some(args: any): any;

            take(args: any): any;

            toArray(args: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static fromWeb(readableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamReadable: any, options: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static fromWeb(writableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamWritable: any): any;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Duplex.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static PassThrough: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static PassThrough: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static PassThrough: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.PassThrough.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Readable: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Readable.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static fromWeb(writableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamWritable: any): any;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Writable {
                    constructor(options: any);

                    cork(): void;

                    destroy(err: any, cb: any): any;

                    end(chunk: any, encoding: any, cb: any): any;

                    pipe(): void;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static WritableState: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Writable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class WritableState {
                    constructor(options: any, stream: any, isDuplex: any);

                    getBuffer(): any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Writable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Writable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Stream.Writable.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Readable: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Transform.Writable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace finished {
            function finished(stream: any, opts: any): any;

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Writable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            asIndexedPairs(args: any): any;

            destroy(err: any, cb: any): any;

            drop(args: any): any;

            every(args: any): any;

            filter(args: any): any;

            find(args: any): any;

            flatMap(args: any): any;

            forEach(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            reduce(args: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            some(args: any): any;

            take(args: any): any;

            toArray(args: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static fromWeb(readableStream: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(streamReadable: any, options: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): void;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static fromWeb(pair: any, options: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static toWeb(duplex: any): any;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class WritableState {
            constructor(options: any, stream: any, isDuplex: any);

            getBuffer(): any;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static PassThrough: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Duplex.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static PassThrough: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static PassThrough: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static PassThrough: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static PassThrough: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.PassThrough.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Readable: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Readable: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class Transform {
                constructor(options: any);

                static Readable: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Stream.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Readable.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Readable: any;

                static Stream: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Transform {
                constructor(options: any);

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Transform {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Transform {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Transform.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Transform.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Stream.Transform.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static defaultMaxListeners: number;

                static errorMonitor: any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            class PassThrough {
                constructor(options: any);

                static PassThrough: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(body: any): any;

                static fromWeb(pair: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(duplex: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                asIndexedPairs(args: any): any;

                destroy(err: any, cb: any): any;

                drop(args: any): any;

                every(args: any): any;

                filter(args: any): any;

                find(args: any): any;

                flatMap(args: any): any;

                forEach(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                reduce(args: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                some(args: any): any;

                take(args: any): any;

                toArray(args: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Readable: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static from(iterable: any, opts: any): any;

                static fromWeb(readableStream: any, options: any): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static toWeb(streamReadable: any, options: any): any;

                static usingDomains: boolean;

                static wrap(src: any, options: any): any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal(signal: any, stream: any): any;

                static captureRejectionSymbol: any;

                static captureRejections: boolean;

                static compose(streams: any): any;

                static defaultMaxListeners: number;

                static destroy(stream: any, err: any): void;

                static errorMonitor: any;

                static finished(stream: any, options: any, callback: any, ...args: any[]): any;

                static getEventListeners(emitterOrTarget: any, type: any): any;

                static init(opts: any): void;

                static isDisturbed(stream: any): any;

                static isErrored(stream: any): any;

                static isReadable(stream: any): any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount(emitter: any, type: any): any;

                static on(emitter: any, event: any, options: any): any;

                static once(emitter: any, name: any, options: any): any;

                static pipeline(streams: any): any;

                static setMaxListeners(n: any, eventTargets: any): void;

                static usingDomains: boolean;

            }

            namespace Duplex {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Duplex.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Duplex.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Duplex.promises
                    const pipeline: any;

                }

            }

            namespace EventEmitter {
                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace EventEmitterAsyncResource {
                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

            }

            namespace PassThrough {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.PassThrough.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.PassThrough.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.PassThrough.promises
                    const pipeline: any;

                }

            }

            namespace Readable {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class ReadableState {
                    constructor(options: any, stream: any, isDuplex: any);

                }

                class Stream {
                    constructor(opts: any);

                    pipe(dest: any, options: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Readable.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Readable.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Readable.promises
                    const pipeline: any;

                }

            }

            namespace Stream {
                class Duplex {
                    constructor(options: any);

                    cork(): void;

                    end(chunk: any, encoding: any, cb: any): any;

                    setDefaultEncoding(encoding: any): any;

                    uncork(): void;

                    write(chunk: any, encoding: any, cb: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class EventEmitter {
                    constructor(opts: any);

                    addListener(type: any, listener: any): any;

                    emit(type: any, args: any): any;

                    eventNames(): any;

                    getMaxListeners(): any;

                    listenerCount(type: any): any;

                    listeners(type: any): any;

                    off(type: any, listener: any): any;

                    on(type: any, listener: any): any;

                    once(type: any, listener: any): any;

                    prependListener(type: any, listener: any): any;

                    prependOnceListener(type: any, listener: any): any;

                    rawListeners(type: any): any;

                    removeAllListeners(type: any, ...args: any[]): any;

                    removeListener(type: any, listener: any): any;

                    setMaxListeners(n: any): any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class EventEmitterAsyncResource {
                    constructor(...args: any[]);

                    emit(...args: any[]): void;

                    emitDestroy(...args: any[]): void;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static defaultMaxListeners: any;

                    static errorMonitor: any;

                    static getEventListeners: any;

                    static init: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static setMaxListeners: any;

                    static usingDomains: any;

                }

                class PassThrough {
                    constructor(options: any);

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                class Readable {
                    constructor(options: any);

                    addListener(ev: any, fn: any): any;

                    asIndexedPairs(args: any): any;

                    destroy(err: any, cb: any): any;

                    drop(args: any): any;

                    every(args: any): any;

                    filter(args: any): any;

                    find(args: any): any;

                    flatMap(args: any): any;

                    forEach(args: any): any;

                    isPaused(): any;

                    iterator(options: any): any;

                    map(args: any): any;

                    off(ev: any, fn: any): any;

                    on(ev: any, fn: any): any;

                    pause(): any;

                    pipe(dest: any, pipeOpts: any): any;

                    push(chunk: any, encoding: any): any;

                    read(n: any): any;

                    reduce(args: any): any;

                    removeAllListeners(ev: any, ...args: any[]): any;

                    removeListener(ev: any, fn: any): any;

                    resume(): any;

                    setEncoding(enc: any): any;

                    some(args: any): any;

                    take(args: any): any;

                    toArray(args: any): any;

                    unpipe(dest: any): any;

                    unshift(chunk: any, encoding: any): any;

                    wrap(stream: any): any;

                    static Duplex: any;

                    static EventEmitter: any;

                    static EventEmitterAsyncResource: any;

                    static PassThrough: any;

                    static Readable: any;

                    static ReadableState: any;

                    static Stream: any;

                    static Transform: any;

                    static Writable: any;

                    static addAbortSignal: any;

                    static captureRejectionSymbol: any;

                    static captureRejections: any;

                    static compose: any;

                    static defaultMaxListeners: any;

                    static destroy: any;

                    static errorMonitor: any;

                    static finished: any;

                    static from: any;

                    static fromWeb: any;

                    static getEventListeners: any;

                    static init: any;

                    static isDisturbed: any;

                    static isErrored: any;

                    static isReadable: any;

                    static kMaxEventTargetListeners: any;

                    static kMaxEventTargetListenersWarned: any;

                    static listenerCount: any;

                    static on: any;

                    static once: any;

                    static pipeline: any;

                    static promises: any;

                    static setMaxListeners: any;

                    static toWeb: any;

                    static usingDomains: any;

                    static wrap: any;

                }

                namespace finished {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Stream.finished
                    const finished: any;

                }

                namespace promises {
                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Stream.promises
                    const finished: any;

                    // Too-deep object hierarchy from r7insight_node.Writable.Transform.Stream.promises
                    const pipeline: any;

                }

            }

            namespace finished {
                function finished(stream: any, opts: any): any;

            }

            namespace promises {
                function finished(stream: any, opts: any): any;

                function pipeline(streams: any): any;

            }

        }

        namespace finished {
            function finished(stream: any, opts: any): any;

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace finished {
        function finished(stream: any, opts: any): any;

    }

    namespace promises {
        function finished(stream: any, opts: any): any;

        function pipeline(streams: any): any;

    }

}

